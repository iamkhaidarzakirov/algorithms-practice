"""Заполнение матрицы разными способами"""


def fill_matrix_casual(n: int, m: int) -> list[list]:
    matrix = [[0] * m for i in range(n)]
    filler = 1
    for i in range(len(matrix)):
        row = matrix[i]
        for j in range(0, len(row)):
            row[j] = filler
            filler += 1

    return matrix


def fill_matrix_as_snake(n: int, m: int) -> list[list]:
    matrix = [[0] * m for i in range(n)]
    filler = 1
    for i in range(len(matrix)):
        row = matrix[i]
        for j in range(0, len(row)):
            if i % 2 == 0:
                row[j] = filler
                filler += 1
            else:
                j += 1
                row[-j] = filler
                filler += 1

    return matrix


def sqr_matrix_spiral(n: int) -> list[list[int]]:
    """Функция заполнения квадратной матрицы по спирали, по часовой стрелке с подробными комментариями"""
    matrix = [[0] * n for _ in range(n)]
    # Движение начинается слева-направо
    i, j = 0, 0  # Строка и столбец таблицы с числами
    di, dj = 0, 1  # 0 — нет движения, 1 — движение вперед / вниз, -1 — движение назад / вверх

    # заполняем матрицу числами от 1 до n * n
    for number in range(1, n * n + 1):
        matrix[i][j] = number  # переопределяем 0 на соответствующее значение
        # Проверка следующего индекса
        if matrix[(i + di) % n][(j + dj) % n]:
            """1. Если следующий индекс меньше размера массива, то остаток от деления на длину массива будет равен этому
            индексу. Значит элемент с таким индексом существует и он равен 0. Число 0 логически это False и 
            условие не будет выполнено. Направление не поменяется.
            2. Если следующий индекс равен длине массива, то элемента с таким индексом не может существовать. Поэтому 
            остаток от деления индекса на длину массива будет равен индексу первого / последнего элемента в зависимости 
            от направления (0, -1). Значение этого элемента уже больше нуля, а логически это True, поэтому условие будет 
            истинным и поменяется направление."""
            di, dj = dj, -di  # по умолчанию 0, 1, далее по часовой стрелке 1,0 -> 0, -1, -> -1, 0 -> и снова 0, 1

        # Шаг / в зависимости от направления один параметр стоит на месте, другой увеличивается или уменьшается
        i += di
        j += dj

    return matrix


if __name__ == '__main__':
    m = 5
    # print(*fill_matrix_as_snake(a, b), sep='\n')
    # print(*fill_matrix_casual(a, b), sep='\n')
    print(*sqr_matrix_spiral(m), sep='\n')
